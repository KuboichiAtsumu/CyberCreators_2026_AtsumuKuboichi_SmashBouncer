//==============================================================================================================================================
//
// ワープホールの処理
// Author : Atsumu Kuboichi
//
//==============================================================================================================================================

//===========================================================================================================
// ヘッダーインクルード
//===========================================================================================================
#include "warphole.h"//ワープホール
#include "gimmickmanager.h"//ギミックマネージャー
#include "effect3D.h"//3Dエフェクト

//===========================================================================================================
// 静的メンバ変数初期化
//===========================================================================================================
int CWarpHole::m_nCntUseWarp = 0;//使用不可のカウント

//===========================================================================================================
// コンストラクタ
//===========================================================================================================
CWarpHole::CWarpHole(int nPriority) : CGimmick(nPriority)
{
	//メンバ変数初期化
	m_bUseWarp = true;//使用フラグ
}

//===========================================================================================================
// デストラクタ
//===========================================================================================================
CWarpHole::~CWarpHole()
{
}

//===========================================================================================================
// 初期化処理
//===========================================================================================================
HRESULT CWarpHole::Init()
{
	//ギミック初期化処理
	if (FAILED(CGimmick::Init()))
	{
		return E_FAIL;
	}

	return S_OK;
}

//===========================================================================================================
// 終了処理
//===========================================================================================================
void CWarpHole::Uninit()
{
	//使用不可のカウント
	m_nCntUseWarp = 0;

	//ギミック終了処理
	CGimmick::Uninit();
}

//===========================================================================================================
// 更新処理
//===========================================================================================================
void CWarpHole::Update()
{
	//ワープホール使用不可のカウントが1以上の場合
	if (m_nCntUseWarp > 0)
	{
		//カウントを減らす
		m_nCntUseWarp--;
	}

	//カウントが0の場合
	if (m_nCntUseWarp <= 0)
	{
		//ワープホールを使える状態にする
		m_bUseWarp = true;
	}

	//ギミック更新処理
	CGimmick::Update();
}

//===========================================================================================================
// 描画処理
//===========================================================================================================
void CWarpHole::Draw()
{
	//エディタモードの場合
	if (CManager::GetScene()->GetEditMode())
	{//描画せずに処理を抜ける
		return;
	}

	//ギミック描画処理
	CGimmick::Draw();
}

//===========================================================================================================
// 移動床の当たり判定
//===========================================================================================================
bool CWarpHole::Collision(D3DXVECTOR3& pos, D3DXVECTOR3& move, D3DXVECTOR3 size, D3DXVECTOR3& rot)
{
	//ローカル変数宣言
	bool bCollision = false;//当たり判定の結果

	//当たり判定の結果を取得
	bCollision = CGimmick::Collision(pos, move, size, rot);

	//当たり判定がtrueの場合
	if (bCollision)
	{
		//ワープ処理
		Warp(pos);
	}

	return bCollision;
}

//===========================================================================================================
// ワープ処理
//===========================================================================================================
void CWarpHole::Warp(D3DXVECTOR3& pos)
{
	//先頭オブジェクトの情報を取得する
	CGimmick* pGimmick = CGame::GetGimmickManager()->GetTop();

	//オブジェクト情報がnullptrになるまで繰り返す
	while (pGimmick != nullptr)
	{
		//次のオブジェクト情報を取得
		CGimmick* pNext = pGimmick->GetNextGimmick();

		//ギミックタイプがワープホールの場合
		if (pGimmick->GetGimmickType() == CGimmick::WARPHOLE)
		{
			//ギミック情報をワープホール情報にダウンキャスト
			CWarpHole* pWarpHole = (CWarpHole*)pGimmick;

			//同じステージに違うワープホールがある場合
			//お互いのワープホールが使用可能な場合
			if (GetPostStageID() == pWarpHole->GetPostStageID()
				&& GetEachStageID() != pWarpHole->GetEachStageID()
				&& m_bUseWarp && pWarpHole->m_bUseWarp)
			{
				//エフェクトの生成
				CEffect3D::Create(CEffect3D::EFFECT_3D_PILLAR, GetPos(), { -D3DX_PI * 0.5f, 0.0, 0.0f }, { 50.0f, 0.0f, 300.0f });

				//位置情報を設定
				pos = pWarpHole->GetPos();

				//SE再生
				CManager::GetSound()->Play(CSound::SE_WARP);

				//エフェクトの生成
				CEffect3D::Create(CEffect3D::EFFECT_3D_PILLAR, pWarpHole->GetPos(), { -D3DX_PI * 0.5f, 0.0, 0.0f }, { 50.0f, 0.0f, 300.0f });

				//お互いのワープホールを一時的に使用できなくする
				m_bUseWarp = false;
				pWarpHole->m_bUseWarp = false;
				m_nCntUseWarp = 30;//再度使用可能になるまでのカウントを設定
			}
		}

		//オブジェクト情報を次の情報に変更する
		pGimmick = pNext;
	}
}
