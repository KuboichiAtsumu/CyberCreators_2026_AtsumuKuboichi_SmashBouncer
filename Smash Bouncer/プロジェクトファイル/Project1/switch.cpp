//==============================================================================================================================================
//
// スイッチの処理
// Author : Atsumu Kuboichi
//
//==============================================================================================================================================

//===========================================================================================================
// ヘッダーインクルード
//===========================================================================================================
#include "switch.h"//スイッチ
#include "block.h"//ブロック
#include "blockmanager.h"//ブロックマネージャー

//===========================================================================================================
// コンストラクタ
//===========================================================================================================
CSwitch::CSwitch(int nPriority) : CGimmick(nPriority)
{
	//メンバ変数初期化
	m_bPush = false;//起動フラグ
}

//===========================================================================================================
// デストラクタ
//===========================================================================================================
CSwitch::~CSwitch()
{
}

//===========================================================================================================
// 初期化処理
//===========================================================================================================
HRESULT CSwitch::Init()
{
	//ギミック初期化処理
	if (FAILED(CGimmick::Init()))
	{
		return E_FAIL;
	}

	return S_OK;
}

//===========================================================================================================
// 終了処理
//===========================================================================================================
void CSwitch::Uninit()
{
	//ギミック終了処理
	CGimmick::Uninit();
}

//===========================================================================================================
// 更新処理
//===========================================================================================================
void CSwitch::Update()
{
	//ギミック更新処理
	CGimmick::Update();
}

//===========================================================================================================
// 描画処理
//===========================================================================================================
void CSwitch::Draw()
{
	//エディタモードの場合
	if (CManager::GetScene()->GetEditMode())
	{//描画せずに処理を抜ける
		return;
	}

	//ギミック描画処理
	CGimmick::Draw();
}

//===========================================================================================================
// 当たり判定
//===========================================================================================================
bool CSwitch::Collision(D3DXVECTOR3& pos, D3DXVECTOR3& move, D3DXVECTOR3 size, D3DXVECTOR3& rot)
{
	//ローカル変数宣言
	bool bCollision = false;//当たり判定の結果

	//スイッチが押されていない場合
	if (!m_bPush)
	{
		//当たり判定の結果を取得
		bCollision = CGimmick::Collision(pos, move, size, rot);

		//当たり判定がtrueの場合
		if (bCollision)
		{
			//押された状態にする
			m_bPush = true;

			//モデル情報取得
			CXfile::CModel aModelInfo = GetModelInfo();

			//スイッチの色を緑色に変更
			for (int nCntMat = 0; nCntMat < (int)aModelInfo.dwNumMat; nCntMat++)
			{
				aModelInfo.Diffuse[nCntMat].r = 0.0f;
				aModelInfo.Diffuse[nCntMat].g = 1.0f;
				aModelInfo.Diffuse[nCntMat].b = 0.0f;
			}

			//モデル情報設定
			BindModel(&aModelInfo);

			//下に沈ませる
			D3DXVECTOR3 Pos = GetPos();//現在の座標を取得
			Pos.y -= 4.0f;//Y座標を下げる
			SetPos(Pos);//更新された座標を設定

			//SE再生
			CManager::GetSound()->Play(CSound::SE_SWITCH);

			//先頭のオブジェクト情報を取得
			CBlock* pBlock = CGame::GetBlockManager()->GetTop();

			//オブジェクト情報がnullptrになるまで繰り返す
			while (pBlock != nullptr)
			{
				//次のオブジェクト情報を取得
				CBlock* pNext = pBlock->GetNextBlock();

				//ブロックタイプが鍵付きブロックの場合
				if (pBlock->GetBlockType() == CBlock::KEY)
				{
					//鍵付きブロックを削除
					pBlock->Uninit();
					break;
				}

				//オブジェクト情報を次の情報に変更する
				pBlock = pNext;
			}
		}
	}

	return bCollision;
}
